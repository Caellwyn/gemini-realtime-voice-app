<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

    <style>
        .demo-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .button-group {
            margin-bottom: 20px;
        }

        .profile-card {
            width: 100%;
            max-width: 780px;
            background: linear-gradient(135deg,#ffe5ec,#ffe9f7 55%,#ffd1e8);
            border: 2px solid #ff8fb5;
            border-radius: 14px;
            padding: 16px 20px 20px 20px;
            box-shadow: 0 4px 10px rgba(255,105,180,0.25);
            position: relative;
        }
        .profile-card:before {
            content: "❤";
            position: absolute;
            top: -14px;
            right: 14px;
            font-size: 28px;
            color: #ff4f86;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
        }
        .profile-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(170px,1fr));
            gap: 12px 18px;
            margin-top: 8px;
        }
        .field-block label { font-weight: 600; font-size: 13px; letter-spacing: .5px; text-transform: uppercase; color:#b52358; }
        .field-block input, .field-block select, .field-block textarea {
            width: 100%;
            border: 1px solid #ff9fc6;
            background: #fff;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 14px;
            resize: vertical;
        }
        .field-block.missing label::after { content: ' • missing'; color:#d62839; font-weight:400; text-transform:none; }
        .profile-actions { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
        .pill-btn { cursor:pointer; background:#ff4f86; border:none; color:#fff; padding:8px 14px; border-radius:24px; font-weight:600; letter-spacing:.5px; box-shadow:0 2px 6px rgba(0,0,0,.15); }
        .pill-btn.alt { background:#ff9fc6; color:#5a0630; }
        .pill-btn.danger { background:#d62839; }
        .profile-status { margin-top:8px; font-size:12px; color:#7a1e3f; font-style:italic; }
        .inline-badge { display:inline-block; background:#fff; border:1px solid #ff7aa8; border-radius:12px; padding:2px 8px; font-size:11px; margin-right:4px; margin-top:4px; }
        .divider-heart { text-align:center; margin:14px 0 4px 0; font-size:18px; color:#ff4f86; }
        .readonly-chip { background:#ffeaf1; border:1px solid #ff9fc6; padding:4px 10px; border-radius:20px; font-size:12px; display:inline-flex; gap:6px; align-items:center; }
        .readonly-chip span { font-weight:600; }
        .fade-in { animation: fade .45s ease; }
        @keyframes fade { from {opacity:0; transform:translateY(4px);} to {opacity:1; transform:translateY(0);} }
        .small-note { font-size:11px; color:#90324f; margin-top:4px; }
    .romance-title { font-family: 'Georgia', serif; font-weight:700; font-size:20px; background:linear-gradient(90deg,#b30047,#ff4f86); -webkit-background-clip: text; background-clip:text; color:transparent; letter-spacing:.5px; }
    </style>
    </style>
</head>

<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
        <header class="mdl-layout__header">
            <div class="mdl-layout__header-row">
                <!-- Title -->
                <span class="mdl-layout-title">Voice Form Fill - Multi Mode (Dating / PDF)</span>
            </div>
        </header>
        <main class="mdl-layout__content">
            <div class="page-content">
                <div class="demo-content">
                    <!-- Mode Selection Gate -->
                    <div id="modeGate" style="display:flex; gap:16px; margin:12px 0 24px 0; flex-wrap:wrap;">
                        <button id="btnModeDating" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored">Use Default Dating Profile Form</button>
                        <button id="btnModePdf" class="mdl-button mdl-js-button mdl-button--raised">Upload AcroForm PDF</button>
                        <span id="modeStatus" style="align-self:center; font-size:12px; color:#555;">Mode not chosen.</span>
                    </div>

                    <!-- PDF Upload Panel (hidden until PDF mode selected) -->
                    <div id="pdfUploadPanel" style="display:none; width:100%; max-width:780px; border:1px solid #ccc; padding:14px; border-radius:8px; background:#fafafa;">
                        <strong>Upload AcroForm PDF</strong>
                        <form id="pdfUploadForm" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <input type="file" id="pdfFileInput" accept="application/pdf" aria-label="PDF file" />
                            <button type="submit" class="mdl-button mdl-js-button mdl-button--raised">Upload & Parse</button>
                            <button type="button" id="btnCancelPdfMode" class="mdl-button mdl-js-button">Cancel</button>
                        </form>
                        <div id="pdfUploadStatus" style="margin-top:8px; font-size:12px; color:#444;"></div>
                        <div id="pdfWarnings" style="margin-top:4px; font-size:11px; color:#b05000;"></div>
                    </div>

                    <!-- Model Selector -->
                    <div style="margin-bottom: 12px; display: flex; gap: 8px; align-items: center;">
                        <label for="modelSelect">Model:</label>
                        <select id="modelSelect" class="mdl-textfield__input">
                            <option value="gemini-2.5-flash-preview-native-audio-dialog">
                                gemini-2.5-flash-preview-native-audio-dialog
                            </option>
                            <option value="gemini-2.0-flash-live-001" selected>gemini-2.0-flash-live-001</option>
                        </select>
                    </div>

                    <!-- Voice Selector -->
                    <div style="margin-bottom: 12px; display: flex; gap: 8px; align-items: center;">
                        <label for="voiceSelect">Voice:</label>
                        <select id="voiceSelect" class="mdl-textfield__input">
                            <option value="Puck" selected>Puck — Conversational, friendly</option>
                            <option value="Charon">Charon — Deep, authoritative</option>
                            <option value="Kore">Kore — Neutral, professional</option>
                            <option value="Fenrir">Fenrir — Warm, approachable</option>
                            <option value="Leda">Leda — Youthful</option>
                            <option value="Orus">Orus — Firm</option>
                            <option value="Aoede">Aoede — Breezy</option>
                            <option value="Callirrhoe">Callirrhoe — Easy-going</option>
                            <option value="Enceladus">Enceladus — Breathy</option>
                            <option value="Iapetus">Iapetus — Clear</option>
                            <option value="Umbriel">Umbriel — Easy-going</option>
                            <option value="Algieba">Algieba — Smooth</option>
                            <option value="Despina">Despina — Smooth</option>
                            <option value="Erinome">Erinome — Clear</option>
                            <option value="Algenib">Algenib — Gravelly</option>
                            <option value="Rasalgethi">Rasalgethi — Informative</option>
                            <option value="Laomedeia">Laomedeia — Upbeat</option>
                            <option value="Achernar">Achernar — Soft</option>
                            <option value="Alnilam">Alnilam — Firm</option>
                            <option value="Schedar">Schedar — Even</option>
                            <option value="Gacrux">Gacrux — Mature</option>
                            <option value="Pulcherrima">Pulcherrima — Forward</option>
                            <option value="Achird">Achird — Friendly</option>
                            <option value="Zubenelgenubi">Zubenelgenubi — Casual</option>
                            <option value="Vindemiatrix">Vindemiatrix — Gentle</option>
                            <option value="Sadachbia">Sadachbia — Lively</option>
                            <option value="Sadaltager">Sadaltager — Knowledgeable</option>
                            <option value="Sulafat">Sulafat — Warm</option>
                            <option value="Zephyr">Zephyr — Bright</option>
                        </select>
                    </div>

                    <!-- VAD Toggle -->
                    <div style="margin-bottom: 12px; display: flex; gap: 8px; align-items: center;">
                        <label class="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="vadCheckbox">
                            <input type="checkbox" id="vadCheckbox" class="mdl-checkbox__input">
                            <span class="mdl-checkbox__label">Enable VAD (auto start/stop)</span>
                        </label>
                    </div>
                    <!-- Voice Control Buttons -->
                    <div class="button-group">
                        <button id="startButton"
                            class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-button--colored">
                            <i class="material-icons">mic</i>
                        </button>
                        <button id="stopButton"
                            class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab">
                            <i class="material-icons">mic_off</i>
                        </button>
                    </div>

                    <!-- Test Mode Toggle -->
                    <div style="padding-bottom: 20px;">
                        <label class="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="testModeCheckbox">
                            <input type="checkbox" id="testModeCheckbox" class="mdl-checkbox__input" checked>
                            <span class="mdl-checkbox__label">Test Mode</span>
                        </label>
                    </div>

                    <!-- Removed light status (legacy) -->

                    <!-- Dating Profile Card -->
                    <div class="profile-card" id="profileCard">
                        <div class="romance-title">Dating Profile Builder</div>
                        <div class="small-note">Speak naturally. The assistant will fill or refine the profile via a structured tool call.</div>
                        <div class="profile-grid" id="profileFields">
                            <div class="field-block" id="field_eye_color">
                                <label for="eyeColorInput">Eye Color</label>
                                <select id="eyeColorInput">
                                    <option value="">(select)</option>
                                    <option value="blue">Blue</option>
                                    <option value="brown">Brown</option>
                                    <option value="green">Green</option>
                                    <option value="hazel">Hazel</option>
                                </select>
                            </div>
                            <div class="field-block" id="field_age">
                                <label for="ageInput">Age</label>
                                <input id="ageInput" type="number" min="1" max="120" placeholder="e.g. 29">
                            </div>
                            <div class="field-block" id="field_todays_date">
                                <label for="todayDateInput">Today's Date</label>
                                <input id="todayDateInput" type="text" placeholder="YYYY-MM-DD">
                            </div>
                            <div class="field-block" style="grid-column:1 / -1;" id="field_ideal_date">
                                <label for="idealDateInput">Ideal Date</label>
                                <textarea id="idealDateInput" rows="2" placeholder="Sunset walk, cozy cafe..." ></textarea>
                            </div>
                        </div>
                        <div class="profile-actions">
                            <button class="pill-btn danger" id="btnResetProfile" title="Clear local profile state">Reset</button>
                        </div>
                        <div class="profile-status" id="profileStatus"></div>
                        <div class="divider-heart">♡</div>
                        <div id="profileBadges"></div>
                    </div>

                    <!-- Generic PDF Form Collector (hidden until PDF mode active + schema loaded) -->
                    <div class="profile-card" id="pdfFormCard" style="display:none;">
                        <div style="font-weight:700; font-size:18px; margin-bottom:4px;">PDF Form Field Collector</div>
                        <div class="small-note" id="pdfFormMetaNote">Upload a PDF with AcroForm fields (first page only). All fields required.</div>
                        <div id="pdfFieldSummary" class="profile-status" style="margin-top:4px;"></div>
                        <div id="pdfFieldsContainer" class="profile-grid" style="margin-top:10px;"></div>
                        <div style="display:flex; flex-wrap:wrap; gap:8px; margin-top:14px;">
                            <button class="pill-btn danger" id="btnResetPdf" title="Reset PDF session">Reset</button>
                            <button class="pill-btn" id="btnDownloadPdf" style="display:none;">Download Filled PDF</button>
                        </div>
                        <div id="pdfCompletionBanner" class="profile-status" style="margin-top:10px;"></div>
                    </div>

                    <!-- Text Output -->
                    <div style="width: 100%; max-width: 780px;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <strong>Response modality:</strong>
                            <span id="modalityLabel">AUDIO</span>
                            <button id="clearTextBtn" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" style="margin-left:auto;">
                                Clear Text
                            </button>
                        </div>
                        <div id="responseTextBox" style="min-height: 120px; border: 1px solid #ddd; border-radius: 4px; padding: 8px; overflow-y:auto; white-space:pre-wrap;"></div>
                    </div>
                    <div id="chatLog"></div>
                </div>
            </div>
        </main>
    </div>

    <script defer>
        const URL = "ws://localhost:9082";
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    // Mode controls
    const btnModeDating = document.getElementById('btnModeDating');
    const btnModePdf = document.getElementById('btnModePdf');
    const modeStatus = document.getElementById('modeStatus');
    const pdfUploadPanel = document.getElementById('pdfUploadPanel');
    const pdfUploadForm = document.getElementById('pdfUploadForm');
    const pdfFileInput = document.getElementById('pdfFileInput');
    const pdfUploadStatus = document.getElementById('pdfUploadStatus');
    const pdfWarnings = document.getElementById('pdfWarnings');
    const btnCancelPdfMode = document.getElementById('btnCancelPdfMode');
    const pdfFormCard = document.getElementById('pdfFormCard');
    const pdfFieldsContainer = document.getElementById('pdfFieldsContainer');
    const pdfFieldSummary = document.getElementById('pdfFieldSummary');
    const pdfFormMetaNote = document.getElementById('pdfFormMetaNote');
    const btnResetPdf = document.getElementById('btnResetPdf');
    const btnDownloadPdf = document.getElementById('btnDownloadPdf');
    const pdfCompletionBanner = document.getElementById('pdfCompletionBanner');
    let webSocket = null;
        let audioContext = null;
        let playbackWorkletNode = null;
        let recordingWorkletNode = null;
        let mediaStream = null;
    const clearTextBtn = document.getElementById('clearTextBtn');
    const modalityLabel = document.getElementById('modalityLabel');
    const responseTextBox = document.getElementById('responseTextBox');

        // Profile form elements
    const eyeColorInput = document.getElementById('eyeColorInput');
        const ageInput = document.getElementById('ageInput');
        const idealDateInput = document.getElementById('idealDateInput');
        const todayDateInput = document.getElementById('todayDateInput');
        const btnResetProfile = document.getElementById('btnResetProfile');
        const profileStatus = document.getElementById('profileStatus');
        const profileBadges = document.getElementById('profileBadges');

        // Local profile state mirror
    const profileState = { eye_color: null, age: null, ideal_date: null, todays_date: null };
    const confirmedState = { eye_color: false, age: false, ideal_date: false, todays_date: false };
    const manualOverrideTimestamp = { eye_color:0, age:0, ideal_date:0, todays_date:0 };
    const lastToolApplyTimestamp   = { eye_color:0, age:0, ideal_date:0, todays_date:0 };
    let completionPromptShown = false;
    let sessionCompleted = false;
    // Mode + PDF session state
    let currentMode = null; // 'dating' | 'pdf'
    let pdfSchema = null;
    let pdfFormId = null;
    let pdfState = {}; // fieldName -> value
    let pdfConfirmed = {}; // fieldName -> bool
    let pdfAllConfirmed = false;
    let pdfDownloadReady = false;
    let pdfFieldsOrder = [];

    function updateProfileUI() {
            // Always overwrite visible inputs with latest state (manual overrides already applied)
            if (profileState.eye_color !== null) eyeColorInput.value = profileState.eye_color;
            if (profileState.age !== null) ageInput.value = profileState.age;
            if (profileState.ideal_date !== null) idealDateInput.value = profileState.ideal_date;
            if (profileState.todays_date !== null) todayDateInput.value = profileState.todays_date;

            const missing = Object.entries(profileState).filter(([_,v]) => !v);
            const allFilled = missing.length === 0;

            // Field badge display with confirmation status
            profileBadges.innerHTML = '';
            ['eye_color','age','ideal_date','todays_date'].forEach(k => {
                const v = profileState[k];
                if (!v) return;
                const badge = document.createElement('span');
                badge.className = 'inline-badge fade-in';
                badge.textContent = k + ': ' + (''+v).slice(0,40) + (confirmedState[k] ? ' ✓' : ' (unconfirmed)');
                profileBadges.appendChild(badge);
            });

            // Mark missing visually
            ['eye_color','age','ideal_date','todays_date'].forEach(f => {
                const el = document.getElementById('field_'+f.replace('todays_date','todays_date'));
                if (!el) return;
                if (!profileState[f]) el.classList.add('missing'); else el.classList.remove('missing');
            });

            const unconfirmed = Object.entries(confirmedState).filter(([k,v]) => profileState[k] && !v).map(([k])=>k);
            if (!allFilled) {
                profileStatus.textContent = `${missing.length} field(s) still missing.`;
            } else if (unconfirmed.length) {
                profileStatus.textContent = 'All fields filled. Awaiting confirmation for: ' + unconfirmed.join(', ');
            } else {
                profileStatus.textContent = 'All fields filled & confirmed.';
            }

            // Trigger completion prompt only when all filled AND all confirmed
            if (allFilled && unconfirmed.length === 0 && !completionPromptShown && !sessionCompleted) {
                showCompletionPrompt();
            }
        }
    function resetProfileState() {
            profileState.eye_color = null; profileState.age = null; profileState.ideal_date = null; profileState.todays_date = null;
            eyeColorInput.value=''; ageInput.value=''; idealDateInput.value=''; todayDateInput.value='';
            updateProfileUI();
        }
    // Removed buildMissingFieldsPrompt & buildUserHintPrompt (no longer used)
    function sendTextPrompt(text) {
            if (!webSocket || webSocket.readyState !== WebSocket.OPEN) { console.warn('WS not open'); return; }
            webSocket.send(JSON.stringify({ realtime_input: { text } }));
        }
        btnResetProfile.addEventListener('click', ()=> { resetProfileState(); updateProfileUI(); });
        function sendUserEdit(field, value) {
            if (!webSocket || webSocket.readyState !== WebSocket.OPEN || document.getElementById('testModeCheckbox').checked) return;
            webSocket.send(JSON.stringify({ user_edit: { field, value } }));
            console.log('Sent user_edit', field, value);
        }
        function markConfirmed(field) { confirmedState[field] = true; }
        // Manual overrides: update state, mark confirmed, timestamp, send delta
        eyeColorInput.addEventListener('change', () => {
            const v = (eyeColorInput.value||'').toLowerCase();
            if (!v) { profileState.eye_color = null; confirmedState.eye_color=false; updateProfileUI(); return; }
            if (!['blue','brown','green','hazel'].includes(v)) { alert('Invalid eye color'); eyeColorInput.value=''; return; }
            profileState.eye_color = v; confirmedState.eye_color=true; manualOverrideTimestamp.eye_color=Date.now(); sendUserEdit('eye_color', v); updateProfileUI();
        });
        ageInput.addEventListener('change', () => {
            const raw = ageInput.value.trim();
            if (!raw) { profileState.age=null; confirmedState.age=false; updateProfileUI(); return; }
            const n = parseInt(raw,10); if (isNaN(n) || n<1 || n>120) { alert('Age must be 1-120'); ageInput.value=''; return; }
            profileState.age = n; confirmedState.age=true; manualOverrideTimestamp.age=Date.now(); sendUserEdit('age', n); updateProfileUI();
        });
        idealDateInput.addEventListener('change', () => {
            const txt = idealDateInput.value.trim();
            if (!txt) { profileState.ideal_date=null; confirmedState.ideal_date=false; updateProfileUI(); return; }
            profileState.ideal_date = txt; confirmedState.ideal_date=true; manualOverrideTimestamp.ideal_date=Date.now(); sendUserEdit('ideal_date', txt); updateProfileUI();
        });
        todayDateInput.addEventListener('change', () => {
            const td = todayDateInput.value.trim();
            if (!td) { profileState.todays_date=null; confirmedState.todays_date=false; updateProfileUI(); return; }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(td)) { alert('Date must be YYYY-MM-DD'); return; }
            profileState.todays_date = td; confirmedState.todays_date=true; manualOverrideTimestamp.todays_date=Date.now(); sendUserEdit('todays_date', td); updateProfileUI();
        });
    // Start with ALL fields blank; do not prefill today's date (user must state it explicitly)
    updateProfileUI();

        function showCompletionPrompt() {
            completionPromptShown = true;
            const container = document.createElement('div');
            container.id = 'completionPrompt';
            container.className = 'fade-in';
            container.style.marginTop = '14px';
            container.style.padding = '12px 14px';
            container.style.border = '1px solid #ff7aa8';
            container.style.background = '#fff5f9';
            container.style.borderRadius = '10px';
            container.innerHTML = `
                <strong>Profile complete.</strong><br/>
                Please confirm everything looks correct.
                <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
                   <button class="pill-btn" id="btnConfirmProfile">Confirm & Finish</button>
                   <button class="pill-btn alt" id="btnRestartProfile">Start Over</button>
                </div>
            `;
            profileCard.appendChild(container);
            const confirmBtn = container.querySelector('#btnConfirmProfile');
            const restartBtn = container.querySelector('#btnRestartProfile');
            confirmBtn.addEventListener('click', confirmAndCloseSession);
            restartBtn.addEventListener('click', restartSession);
        }

        function confirmAndCloseSession() {
            sessionCompleted = true;
            // Stop audio and close websocket gracefully
            try { stopAudioInput(); } catch(e) {}
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                try { webSocket.close(1000, 'profile complete'); } catch(e) {}
            }
            profileStatus.textContent = 'Profile complete, voice assistant disconnected.';
            addCompletionBanner();
        }

        function restartSession() {
            // Remove completion UI and reset state
            sessionCompleted = false;
            completionPromptShown = false;
            const prompt = document.getElementById('completionPrompt');
            if (prompt) prompt.remove();
            resetProfileState();
            profileStatus.textContent = 'Session restarted. Provide or request fields again.';
            if (!document.getElementById('testModeCheckbox').checked) {
                connect();
            }
        }

        function addCompletionBanner() {
            let banner = document.getElementById('completionBanner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'completionBanner';
                banner.style.marginTop = '10px';
                banner.style.padding = '10px 14px';
                banner.style.background = '#e3ffe9';
                banner.style.border = '1px solid #57c27c';
                banner.style.borderRadius = '8px';
                banner.style.fontSize = '13px';
                banner.style.color = '#225c38';
                banner.innerHTML = '✔ Profile confirmed. Assistant session closed.';
                profileCard.appendChild(banner);
            }
        }

        window.addEventListener("load", async () => {
            const testModeCheckbox = document.getElementById('testModeCheckbox');
            
            // Update component state for MDL
            componentHandler.upgradeDom();

            testModeCheckbox.addEventListener('change', (event) => {
                if (event.currentTarget.checked) {
                    if (webSocket) {
                        webSocket.close();
                        webSocket = null;
                        console.log("Test mode enabled. WebSocket disconnected.");
                    }
                } else {
                    console.log("Test mode disabled. Connecting WebSocket.");
                    connect();
                }
            });
        });

    function connect() {
            if (document.getElementById('testModeCheckbox').checked) {
                console.log("Test mode is on. Skipping WebSocket connection.");
                return;
            }
            console.log("connecting: ", URL);

            webSocket = new WebSocket(URL);

            webSocket.onclose = (event) => {
                console.log("websocket closed: ", event);
                if (!document.getElementById('testModeCheckbox').checked) {
                    alert("Connection closed");
                }
            };

            webSocket.onerror = (event) => {
                console.log("websocket error: ", event);
            };

            webSocket.onopen = (event) => {
                console.log("websocket open: ", event);
                sendInitialSetupMessage();
            };

            webSocket.onmessage = receiveMessage;
        }

        function sendInitialSetupMessage() {
            console.log("sending setup message");
            const model = document.getElementById('modelSelect').value;
            const voiceName = document.getElementById('voiceSelect').value;
            const enableVad = document.getElementById('vadCheckbox').checked;

            // Only AUDIO modality for native audio dialog model
            const responseModalities = ["AUDIO"]; modalityLabel.textContent = 'AUDIO';

            const setup_client_message = {
                setup: {
                    generation_config: { response_modalities: responseModalities, temperature: 0.9 },
                    model: model,
                    voice_name: voiceName,
                    enable_vad: enableVad,
                    mode: currentMode === 'pdf' ? 'pdf_form' : 'dating'
                }
            };

            // For PDF mode, include field names in setup so tools can be predeclared
            if (currentMode === 'pdf' && pdfSchema && pdfFieldsOrder.length > 0) {
                setup_client_message.setup.pdf_field_names = pdfFieldsOrder;
                setup_client_message.setup.pdf_form_id = pdfFormId;
            }

            webSocket.send(JSON.stringify(setup_client_message));
        }


        function sendVoiceMessage(pcmData) {
            const buffer = pcmData.buffer;
            const base64 = btoa(
                String.fromCharCode.apply(null, new Uint8Array(buffer))
            );

            if (document.getElementById('testModeCheckbox').checked) {
                console.log("Test mode: looping back audio with a 500ms delay.");
                setTimeout(() => {
                    injestAudioChuckToPlay(base64);
                }, 500);
                return;
            }

            if (webSocket == null || webSocket.readyState !== WebSocket.OPEN) {
                console.log("websocket not initialized or not open");
                return;
            }

            const payload = {
                realtime_input: {
                    media_chunks: [{
                            mime_type: "audio/pcm",
                            data: base64,
                        }
                    ],
                },
            };

            webSocket.send(JSON.stringify(payload));
            console.log("sent: ", payload);
        }

    function receiveMessage(event) {
            const messageData = JSON.parse(event.data);
            const response = new Response(messageData);

            // Tool response for profile
            if (messageData.profile_tool_response) {
                try {
                    const r = messageData.profile_tool_response; const now=Date.now();
                    ['eye_color','age','ideal_date','todays_date'].forEach(k=>{ 
                        if (r[k]!==undefined && r[k]!==null) {
                            // Only overwrite if user didn't override after last tool update
                            if (!manualOverrideTimestamp[k] || manualOverrideTimestamp[k] <= lastToolApplyTimestamp[k]) {
                                profileState[k]=r[k]; confirmedState[k]=true; lastToolApplyTimestamp[k]=now;
                            }
                        }
                    });
                    updateProfileUI();
                } catch(err){ console.warn('Error applying profile tool response', err); }
            }
            // PDF completion notification
            if (messageData.form_complete) {
                showPdfConfirmationPrompt();
            }
            if (messageData.download_ready) {
                pdfDownloadReady = true;
                pdfCompletionBanner.textContent = 'Download ready. You may now download the filled PDF.';
                btnDownloadPdf.style.display='inline-block';
            }
            if (messageData.error && messageData.error === 'unknown_form') {
                showInactivityBanner();
            }

            // PDF form tool responses
            if (messageData.form_tool_response) {
                const { updated, remaining } = messageData.form_tool_response;
                Object.entries(updated || {}).forEach(([k,v]) => {
                    pdfState[k] = v; pdfConfirmed[k] = true;
                });
                refreshPdfFieldsUI();
            }
            if (messageData.form_state) {
                // Could update summary if needed
                refreshPdfFieldsUI();
            }
            if (messageData.download_ready) {
                pdfDownloadReady = true;
                pdfCompletionBanner.textContent = 'Download ready.';
                btnDownloadPdf.style.display='inline-block';
            }

            if (response.text) {
                if (modalityLabel.textContent === 'TEXT') appendToResponseBox(response.text); else displayMessage('GEMINI: ' + response.text);
            }
            if (response.audioData) {
                injestAudioChuckToPlay(response.audioData, messageData.audio_mime_type || 'audio/pcm');
            }
        }

        function appendToResponseBox(text) {
            if (!text) return;
            responseTextBox.textContent += text;
            responseTextBox.scrollTop = responseTextBox.scrollHeight;
        }

        function base64ToArrayBuffer(base64) {
          const binaryString = window.atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        }

        function convertPCM16LEToFloat32(pcmData) {
           const inputArray = new Int16Array(pcmData);
           const float32Array = new Float32Array(inputArray.length);

           for (let i = 0; i < inputArray.length; i++) {
              float32Array[i] = inputArray[i] / 32768;
           }

          return float32Array;
        }


        async function injestAudioChuckToPlay(base64AudioChunk, mimeType) {
           try {
            console.log("injestAudioChuckToPlay: Received audio chunk for playback.");
              if (!playbackWorkletNode) {
                console.error("Playback worklet node not initialized.");
                return;
              }
              if (audioContext && audioContext.state === "suspended") {
                 await audioContext.resume();
                 console.log("injestAudioChuckToPlay: Resumed playback audio context.");
              }
              const arrayBuffer = base64ToArrayBuffer(base64AudioChunk);
             let float32Data = convertPCM16LEToFloat32(arrayBuffer);
             // Simple resample safeguard if sampleRate mismatch (assume server 24k -> context 16k) based on length heuristics
             if (audioContext.sampleRate === 16000 && float32Data.length % 3 === 0 && mimeType.includes('pcm')) {
                const factor = 3/2; // 24k -> 16k (approx) if length divisible by 3
                if (float32Data.length / factor > 128) {
                    const targetLen = Math.round(float32Data.length / factor);
                    const down = new Float32Array(targetLen);
                    for (let i=0; i<targetLen; i++) {
                        const srcIndex = i * factor;
                        const i0 = Math.floor(srcIndex);
                        const i1 = Math.min(i0+1, float32Data.length-1);
                        const t = srcIndex - i0;
                        down[i] = float32Data[i0]*(1-t) + float32Data[i1]*t;
                    }
                    float32Data = down;
                }
             }
             playbackWorkletNode.port.postMessage(float32Data);
             console.log("injestAudioChuckToPlay: Sent audio data to playback processor.");
            } catch (error) {
               console.error("Error processing audio chunk:", error);
            }
        }


        async function ensureConnected() {
            if (document.getElementById('testModeCheckbox').checked) return;
            if (webSocket && webSocket.readyState === WebSocket.OPEN) return;

            const waitForOpen = new Promise((resolve, reject) => {
                let opened = false;
                const timeout = setTimeout(() => {
                    if (!opened) reject(new Error('WebSocket open timeout'));
                }, 4000);
                const onOpen = () => {
                    opened = true;
                    clearTimeout(timeout);
                    if (webSocket) webSocket.removeEventListener('open', onOpen);
                    resolve();
                };
                if (!webSocket || webSocket.readyState !== WebSocket.CONNECTING) {
                    connect();
                }
                if (webSocket) webSocket.addEventListener('open', onOpen);
            });
            try { await waitForOpen; } catch (e) { console.warn('Could not ensure WS open before recording:', e); }
        }

        async function startAudioInput() {
            try {
                console.log("startAudioInput: Attempting to start audio input...");

                // Open WebSocket first when not in test mode
                await ensureConnected();
                if (modalityLabel.textContent === 'TEXT') {
                    responseTextBox.textContent = '';
                }
                
                // Create and resume a single AudioContext
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    console.log("startAudioInput: AudioContext created with 16000 sample rate.");
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log("startAudioInput: AudioContext resumed.");
                }

                // Get microphone permission and the audio stream
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000
                    }
                });
                console.log("startAudioInput: Successfully got user media (microphone).");

                // Load both worklet modules
                await Promise.all([
                    audioContext.audioWorklet.addModule('/recording-processor.js'),
                    audioContext.audioWorklet.addModule('/pcm-processor.js')
                ]);
                console.log("startAudioInput: All audio worklet modules added.");
                
                // Setup recording pipeline
                const source = audioContext.createMediaStreamSource(mediaStream);
                console.log("startAudioInput: MediaStreamSource created.");
                recordingWorkletNode = new AudioWorkletNode(audioContext, 'recording-processor', {
                    processorOptions: {
                        sampleRate: 16000
                    }
                });
                console.log("startAudioInput: RecordingWorkletNode created.");
                recordingWorkletNode.port.onmessage = (event) => {
                    console.log("startAudioInput: Received message from recording processor.");
                    sendVoiceMessage(event.data);
                };
                source.connect(recordingWorkletNode);
                console.log("startAudioInput: Recording pipeline connected.");

                // Setup playback pipeline
                playbackWorkletNode = new AudioWorkletNode(audioContext, "pcm-processor");
                console.log("startAudioInput: PlaybackWorkletNode created.");
                playbackWorkletNode.connect(audioContext.destination);
                console.log("startAudioInput: Playback pipeline connected.");


            } catch (error) {
                console.error("Error starting audio input:", error);
                alert("Could not start audio recording: " + error.message);
            }
        }

        function stopAudioInput() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (recordingWorkletNode) {
                recordingWorkletNode.disconnect();
                recordingWorkletNode = null;
            }
            if (playbackWorkletNode) {
                playbackWorkletNode.disconnect();
                playbackWorkletNode = null;
            }
            if (audioContext) {
                audioContext.close().then(() => {
                    audioContext = null;
                });
            }

            // Signal end of audio stream turn (allows model to respond sooner)
            if (webSocket && webSocket.readyState === WebSocket.OPEN && !document.getElementById('testModeCheckbox').checked) {
                try { webSocket.send(JSON.stringify({ realtime_input: { audio_stream_end: true } })); console.log('Sent audio_stream_end'); } catch(e){ console.warn('Failed to send audio_stream_end', e); }
            }
        }

        function displayMessage(message) {
           console.log(message);
            addParagraphToDiv("chatLog", message);
        }

    // (Removed legacy light status updater)

        function addParagraphToDiv(divId, text) {
           const newParagraph = document.createElement("p");
           newParagraph.textContent = text;
           const div = document.getElementById(divId);
           div.appendChild(newParagraph);
        }

        startButton.addEventListener('click', () => { if(!currentMode){alert('Select a mode first.'); return;} startAudioInput(); });
        stopButton.addEventListener('click', stopAudioInput);

        // ------- Mode Handling -------
        function setMode(newMode){
            if (currentMode === newMode) return;
            currentMode = newMode;
            modeStatus.textContent = 'Mode: ' + (newMode==='dating' ? 'Dating Profile' : 'PDF Form');
            if (newMode === 'dating') {
                pdfUploadPanel.style.display='none';
                pdfFormCard.style.display='none';
                profileCard.style.display='block';
                if (!document.getElementById('testModeCheckbox').checked) connect();
            } else if (newMode === 'pdf') {
                profileCard.style.display='none';
                pdfUploadPanel.style.display='block';
                pdfFormCard.style.display='none';
            }
        }
        btnModeDating.addEventListener('click', ()=> setMode('dating'));
        btnModePdf.addEventListener('click', ()=> setMode('pdf'));
        btnCancelPdfMode.addEventListener('click', ()=> { setMode(null); modeStatus.textContent='Mode not chosen.'; });

        // ------- PDF Upload Flow -------
        pdfUploadForm.addEventListener('submit', async (e)=>{
            e.preventDefault();
            const file = pdfFileInput.files && pdfFileInput.files[0];
            pdfWarnings.textContent=''; pdfUploadStatus.textContent='';
            if(!file){ pdfUploadStatus.textContent='Select a PDF file.'; return; }
            if(file.size > 5*1024*1024){ pdfUploadStatus.textContent='File too large (>5MB).'; return; }
            pdfUploadStatus.textContent='Uploading...';
            try {
                const formData = new FormData();
                formData.append('file', file);
                const resp = await fetch('/upload_form', { method:'POST', body: formData });
                const data = await resp.json();
                if(!data.ok){ pdfUploadStatus.textContent='Error: '+ (data.message||data.error||'upload failed'); return; }
                let statusLine = 'Parsed '+data.schema.field_count+' field(s).';
                if(data.replaced_previous){ statusLine += ' (Previous form replaced.)'; }
                pdfUploadStatus.textContent = statusLine;
                if(data.warnings){ pdfWarnings.textContent = 'Warnings: '+ data.warnings.join(', '); }
                pdfSchema = data.schema; pdfFormId = data.schema.form_id;
                pdfFieldsOrder = data.schema.fields.map(f=>f.name);
                pdfState = {}; pdfConfirmed = {}; pdfFieldsOrder.forEach(n=>{ pdfState[n]=null; pdfConfirmed[n]=false; });
                // Extra metadata warnings
                const meta = pdfSchema.metadata || {};
                const extraNotes = [];
                if(meta.truncated_to_first_page){ extraNotes.push('Only first page processed.'); }
                if(meta.field_cap_reached){ extraNotes.push('Field cap reached; some fields ignored.'); }
                if(extraNotes.length){ pdfWarnings.textContent += (pdfWarnings.textContent? ' ':'') + extraNotes.join(' '); }
                pdfUploadPanel.style.display='none';
                pdfFormCard.style.display='block';
                refreshPdfFieldsUI();
                // Now connect websocket in PDF mode with schema available for tool predeclaration
                if(!document.getElementById('testModeCheckbox').checked) connect(); else modeStatus.textContent+=' (Test Mode)';
                // No need to send pdf_schema message anymore - schema is in setup message
            } catch(err){
                console.error(err); pdfUploadStatus.textContent='Upload failed.';
            }
        });

        // Remove the sendPdfSchemaIfReady function since schema is now sent in setup

        btnResetPdf.addEventListener('click', async ()=>{
            if(!pdfFormId){ return; }
            await fetch('/reset_form', { method:'POST' });
            pdfSchema=null; pdfFormId=null; pdfState={}; pdfConfirmed={}; pdfFieldsOrder=[]; pdfDownloadReady=false; pdfCompletionBanner.textContent='';
            pdfFormCard.style.display='none';
            pdfUploadPanel.style.display='block';
            modeStatus.textContent='PDF mode: form reset.';
        });

        btnDownloadPdf.addEventListener('click', async ()=>{
            if(!pdfDownloadReady && pdfFormId){ /* Still allow attempt once complete locally */ }
            if(!pdfFormId){ return; }
            const resp = await fetch('/download_filled/'+pdfFormId);
            if(!resp.ok){ alert('Download failed (not ready?)'); return; }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'filled_'+ (pdfSchema?.metadata?.original_filename || 'form') ;
            document.body.appendChild(a); a.click(); a.remove();
            setTimeout(()=>URL.revokeObjectURL(url), 3000);
        });

        function refreshPdfFieldsUI(){
            if(!pdfSchema){ return; }
            pdfFieldsContainer.innerHTML='';
            let missingCount=0; let total=pdfFieldsOrder.length;
            pdfFieldsOrder.forEach(name => {
                const fieldMeta = pdfSchema.fields.find(f=>f.name===name) || { display_name: name };
                const val = pdfState[name];
                if(!val) missingCount++;
                const wrap = document.createElement('div');
                wrap.className = 'field-block'+(val?'' : ' missing');
                const inputId = 'pdf_field_'+name;
                wrap.innerHTML = `<label for="${inputId}">${fieldMeta.display_name}</label><input aria-label="${fieldMeta.display_name}" id="${inputId}" type="text" value="${val?escapeHtml(val):''}" />`;
                const input = wrap.querySelector('input');
                input.addEventListener('change', ()=>{
                    const newVal = input.value.trim();
                    if(!newVal){ pdfState[name]=null; pdfConfirmed[name]=false; refreshPdfFieldsUI(); return; }
                    if(newVal.length > 500){
                        alert('Value truncated to 500 characters.');
                    }
                    // send user_edit directly to websocket if live, else queue local
                    pdfState[name]=newVal.slice(0,500); pdfConfirmed[name]=true;
                    if(webSocket && webSocket.readyState===WebSocket.OPEN){
                        webSocket.send(JSON.stringify({ user_edit: { field: name, value: newVal }}));
                    }
                    refreshPdfFieldsUI();
                });
                pdfFieldsContainer.appendChild(wrap);
            });
            pdfFieldSummary.textContent = `${total-missingCount} of ${total} fields filled.`;
            // Hide any previous confirmation prompt if fields became missing again
            if (missingCount > 0) removePdfConfirmationPrompt();
        }

        function showPdfConfirmationPrompt(){
            if(document.getElementById('pdfConfirmPrompt')) return;
            const div = document.createElement('div');
            div.id = 'pdfConfirmPrompt';
            div.style.marginTop='14px';
            div.style.padding='10px 12px';
            div.style.background='#fff5f1';
            div.style.border='1px solid #f5a076';
            div.style.borderRadius='8px';
            div.style.fontSize='13px';
            div.innerHTML = `<strong>All fields captured.</strong> Please confirm all values are correct.
                <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
                    <button class="pill-btn" id="btnConfirmPdf">Confirm & Generate</button>
                    <button class="pill-btn alt" id="btnReviewPdf">Review Fields</button>
                </div>`;
            pdfFormCard.appendChild(div);
            div.querySelector('#btnConfirmPdf').addEventListener('click', ()=>{
                // Send confirm_form message
                if(webSocket && webSocket.readyState===WebSocket.OPEN){
                    webSocket.send(JSON.stringify({ confirm_form: true }));
                }
                pdfCompletionBanner.textContent='Confirmation sent. Preparing file...';
            });
            div.querySelector('#btnReviewPdf').addEventListener('click', ()=>{ div.remove(); });
        }
        function removePdfConfirmationPrompt(){
            const d = document.getElementById('pdfConfirmPrompt'); if(d) d.remove();
        }

        // ------- Inactivity Handling -------
        let pdfStatusPollTimer = null;
        function startPdfStatusPolling(){
            stopPdfStatusPolling();
            if(!pdfFormId) return;
            pdfStatusPollTimer = setInterval(async ()=>{
                try {
                    const resp = await fetch('/form_status/'+pdfFormId);
                    if(resp.status === 404){ showInactivityBanner(); stopPdfStatusPolling(); return; }
                    if(!resp.ok) return;
                    const data = await resp.json();
                    if(!data.ok){ if(data.error==='unknown_form'){ showInactivityBanner(); stopPdfStatusPolling(); } return; }
                } catch(e){ /* network error ignored */ }
            }, 30000); // every 30s
        }
        function stopPdfStatusPolling(){ if(pdfStatusPollTimer){ clearInterval(pdfStatusPollTimer); pdfStatusPollTimer=null; } }
        function showInactivityBanner(){
            if(!pdfFormCard) return;
            let b = document.getElementById('pdfInactiveBanner');
            if(!b){
                b = document.createElement('div');
                b.id='pdfInactiveBanner';
                b.style.marginTop='12px';
                b.style.padding='10px 12px';
                b.style.background='#ffe8e6';
                b.style.border='1px solid #ff9b92';
                b.style.borderRadius='8px';
                b.style.fontSize='12px';
                b.style.color='#7a1e1a';
                b.textContent = 'Session expired due to inactivity. Please reset or upload a new PDF.';
                pdfFormCard.appendChild(b);
            }
        }

        // Hook status poll start when PDF schema loads
        const originalRefreshPdf = refreshPdfFieldsUI;
        // Already calling refreshPdfFieldsUI in flow; ensure polling begins after schema is set
        function refreshPdfFieldsUIWrapper(){ originalRefreshPdf(); if(currentMode==='pdf' && pdfFormId){ startPdfStatusPolling(); } }
        refreshPdfFieldsUI = refreshPdfFieldsUIWrapper;

        function escapeHtml(str){
            return str.replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }

        // Hook into websocket open to send pdf schema
        const originalConnect = connect;
        connect = function(){
            if (document.getElementById('testModeCheckbox').checked) {
                console.log('Test mode skipping WS connect');
                return;
            }
            console.log('connecting: ', URL);
            webSocket = new WebSocket(URL);
            webSocket.onclose = (event)=>{ console.log('websocket closed: ', event); };
            webSocket.onerror = (event)=>{ console.log('websocket error: ', event); };
            webSocket.onopen = (event)=>{ console.log('websocket open: ', event); sendInitialSetupMessage(); };
            webSocket.onmessage = receiveMessage;
        }


    class Response {
            constructor(data) {
               this.text = null;
               this.audioData = null;
                this.endOfTurn = null;

               if(data.text){
                  this.text = data.text
               }

                if (data.audio) {
                   this.audioData = data.audio;
                }
            }
         }

    // Removed automatic suggestion scheduling; assistant must wait for explicit user answers.
    </script>
</body>

</html>