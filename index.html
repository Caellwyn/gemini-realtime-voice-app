<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
    <link rel="stylesheet" href="/pdfjs/pdf_viewer.css">
    <!-- pdf.js ESM loader (single authoritative instance) -->
    <script type="module">
        import * as pdfjsLib from '/pdfjs/pdf.min.mjs';
        import * as pdfjsViewer from '/pdfjs/pdf_viewer.mjs';
        // Expose minimal globals for legacy inline script expectations
        window.pdfjsLib = pdfjsLib;
        window.pdfjsViewer = pdfjsViewer;
        // Try module worker (preferred for ESM)
        try {
            const worker = new Worker('/pdfjs/pdf.worker.min.mjs', { type: 'module' });
            if (pdfjsLib.GlobalWorkerOptions) {
                pdfjsLib.GlobalWorkerOptions.workerPort = worker;
            }
        } catch(e){
            // Fallback to direct workerSrc (some builds still accept this with .mjs path)
            try { pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdfjs/pdf.worker.min.mjs'; } catch(_){ }
        }
    </script>
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

    <style>
        .demo-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Explicit annotation layer (interactive form widgets) */
        .annotationLayer { position:absolute; left:0; top:0; pointer-events:auto; }
        .annotationLayer :is(input,textarea,select) { box-sizing:border-box; font-size:12px; }
        .annotationLayer .textWidgetAnnotation input,
        .annotationLayer .textWidgetAnnotation textarea,
        .annotationLayer input[type="text"],
        .annotationLayer textarea,
        .annotationLayer select { padding:2px 4px; border:1px solid #c08bb1; background:rgba(255,255,255,.85); }
        .annotationLayer input[type="checkbox"],
        .annotationLayer input[type="radio"] { transform:scale(1.05); }
        .annotationLayer .buttonWidgetAnnotation.pushButton { cursor:pointer; }

        .button-group {
            margin-bottom: 20px;
        }

        .profile-card {
            width: 100%;
            max-width: 780px;
            background: linear-gradient(135deg,#ffe5ec,#ffe9f7 55%,#ffd1e8);
            border: 2px solid #ff8fb5;
            border-radius: 14px;
            padding: 16px 20px 20px 20px;
            box-shadow: 0 4px 10px rgba(255,105,180,0.25);
            position: relative;
        }
        .profile-card:before {
            content: "❤";
            position: absolute;
            top: -14px;
            right: 14px;
            font-size: 28px;
            color: #ff4f86;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
        }
        .profile-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(170px,1fr));
            gap: 12px 18px;
            margin-top: 8px;
        }
        .field-block label { font-weight: 600; font-size: 13px; letter-spacing: .5px; text-transform: uppercase; color:#b52358; }
        .field-block input, .field-block select, .field-block textarea {
            width: 100%;
            border: 1px solid #ff9fc6;
            background: #fff;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 14px;
            resize: vertical;
        }
        .field-block.missing label::after { content: ' • missing'; color:#d62839; font-weight:400; text-transform:none; }
        .profile-actions { display:flex; flex-wrap:wrap; gap:10px; margin-top:14px; }
        .pill-btn { cursor:pointer; background:#ff4f86; border:none; color:#fff; padding:8px 14px; border-radius:24px; font-weight:600; letter-spacing:.5px; box-shadow:0 2px 6px rgba(0,0,0,.15); }
        .pill-btn.alt { background:#ff9fc6; color:#5a0630; }
        .pill-btn.danger { background:#d62839; }
        .profile-status { margin-top:8px; font-size:12px; color:#7a1e3f; font-style:italic; }
        .inline-badge { display:inline-block; background:#fff; border:1px solid #ff7aa8; border-radius:12px; padding:2px 8px; font-size:11px; margin-right:4px; margin-top:4px; }
        .divider-heart { text-align:center; margin:14px 0 4px 0; font-size:18px; color:#ff4f86; }
        .readonly-chip { background:#ffeaf1; border:1px solid #ff9fc6; padding:4px 10px; border-radius:20px; font-size:12px; display:inline-flex; gap:6px; align-items:center; }
        .readonly-chip span { font-weight:600; }
        .fade-in { animation: fade .45s ease; }
        @keyframes fade { from {opacity:0; transform:translateY(4px);} to {opacity:1; transform:translateY(0);} }
        .small-note { font-size:11px; color:#90324f; margin-top:4px; }
    .romance-title { font-family: 'Georgia', serif; font-weight:700; font-size:20px; background:linear-gradient(90deg,#b30047,#ff4f86); -webkit-background-clip: text; background-clip:text; color:transparent; letter-spacing:.5px; }
    </style>
    </style>
</head>

<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
        <header class="mdl-layout__header">
            <div class="mdl-layout__header-row">
                <!-- Title -->
                <span class="mdl-layout-title">Voice Form Fill</span>
                <div style="margin-left:auto; display:flex; gap:8px; align-items:center; font-size:12px;">
                    <label for="logLevelSelect" style="font-weight:600;">Log:</label>
                    <select id="logLevelSelect" class="mdl-textfield__input" style="height:28px;">
                        <option value="error">error</option>
                        <option value="warn">warn</option>
                        <option value="info" selected>info</option>
                        <option value="debug">debug</option>
                        <option value="off">off</option>
                    </select>
                    <label class="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="logVerboseAudio">
                        <input type="checkbox" id="logVerboseAudio" class="mdl-checkbox__input">
                        <span class="mdl-checkbox__label">Audio</span>
                    </label>
                </div>
            </div>
        </header>
        <main class="mdl-layout__content">
            <div class="page-content">
                <div class="demo-content">
                    <!-- PDF Upload Panel -->
                    <div id="pdfUploadPanel" style="width:100%; max-width:780px; border:1px solid #ccc; padding:14px; border-radius:8px; background:#fafafa;">
                        <strong>Upload AcroForm PDF</strong>
                        <form id="pdfUploadForm" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <input type="file" id="pdfFileInput" accept="application/pdf" aria-label="PDF file" />
                            <button type="submit" class="mdl-button mdl-js-button mdl-button--raised">Upload & Parse</button>
                        </form>
                        <div id="pdfUploadStatus" style="margin-top:8px; font-size:12px; color:#444;"></div>
                        <div id="pdfWarnings" style="margin-top:4px; font-size:11px; color:#b05000;"></div>
                    </div>

                    <!-- Voice Assistant Toggle -->
                    <div id="voice-assistant-toggle" style="margin-top: 20px; display: none;">
                        <label class="mdl-switch mdl-js-switch mdl-js-ripple-effect" for="assistantSwitch">
                            <input type="checkbox" id="assistantSwitch" class="mdl-switch__input">
                            <span class="mdl-switch__label">Voice Assistant</span>
                        </label>
                    </div>


                    <!-- Model and Voice Configuration -->
                    <div style="margin-bottom: 12px; display: flex; gap: 16px; align-items: center; flex-wrap: wrap;">
                        <div>
                            <label for="modelSelect">Model:</label>
                            <select id="modelSelect" class="mdl-textfield__input">
                                <option value="gemini-2.5-flash-preview-native-audio-dialog">
                                    gemini-2.5-flash-preview-native-audio-dialog
                                </option>
                                <option value="gemini-2.0-flash-live-001" selected>gemini-2.0-flash-live-001</option>
                            </select>
                        </div>
                        <div>
                            <label for="voiceSelect">Voice:</label>
                            <select id="voiceSelect" class="mdl-textfield__input">
                                <option value="Puck" selected>Puck — Conversational, friendly</option>
                                <option value="Charon">Charon — Deep, authoritative</option>
                                <option value="Kore">Kore — Neutral, professional</option>
                                <option value="Fenrir">Fenrir — Warm, approachable</option>
                                <option value="Leda">Leda — Youthful</option>
                                <option value="Orus">Orus — Firm</option>
                                <option value="Aoede">Aoede — Breezy</option>
                                <option value="Callirrhoe">Callirrhoe — Easy-going</option>
                                <option value="Enceladus">Enceladus — Breathy</option>
                                <option value="Iapetus">Iapetus — Clear</option>
                                <option value="Umbriel">Umbriel — Easy-going</option>
                                <option value="Algieba">Algieba — Smooth</option>
                                <option value="Despina">Despina — Smooth</option>
                                <option value="Erinome">Erinome — Clear</option>
                                <option value="Algenib">Algenib — Gravelly</option>
                                <option value="Rasalgethi">Rasalgethi — Informative</option>
                                <option value="Laomedeia">Laomedeia — Upbeat</option>
                                <option value="Achernar">Achernar — Soft</option>
                                <option value="Alnilam">Alnilam — Firm</option>
                                <option value="Schedar">Schedar — Even</option>
                                <option value="Gacrux">Gacrux — Mature</option>
                                <option value="Pulcherrima">Pulcherrima — Forward</option>
                                <option value="Achird">Achird — Friendly</option>
                                <option value="Zubenelgenubi">Zubenelgenubi — Casual</option>
                                <option value="Vindemiatrix">Vindemiatrix — Gentle</option>
                                <option value="Sadachbia">Sadachbia — Lively</option>
                                <option value="Sadaltager">Sadaltager — Knowledgeable</option>
                                <option value="Sulafat">Sulafat — Warm</option>
                                <option value="Zephyr">Zephyr — Bright</option>
                            </select>
                        </div>
                        <div>
                            <label class="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="vadCheckbox">
                                <input type="checkbox" id="vadCheckbox" class="mdl-checkbox__input">
                                <span class="mdl-checkbox__label">Enable VAD</span>
                            </label>
                        </div>
                    </div>
                    <!-- Inline PDF Viewer Card -->
                    <div class="profile-card" id="pdfFormCard" style="display:none; margin-top: 20px;">
                        <div style="font-weight:700; font-size:18px; margin-bottom:4px;">PDF Form</div>
                        <div class="small-note" id="pdfFormMetaNote">Fields will fill automatically as you (or the AI) provide values.</div>
                        <div id="pdfFieldSummary" class="profile-status" style="margin-top:4px;"></div>
                        <div style="display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 4px 0;">
                            <button class="pill-btn danger" id="btnResetPdf" title="Reset PDF session">Reset</button>
                            <button class="pill-btn" id="btnDownloadPdf" style="display:none;">Download Filled PDF</button>
                        </div>
                        <div id="pdfCompletionBanner" class="profile-status" style="margin-top:6px;"></div>
                        <div id="pdfViewerContainer" style="position:relative; margin-top:12px; border:1px solid #e0b4c9; border-radius:8px; overflow:auto; max-height:900px; background:#fff;">
                            <div id="pdfPages"></div>
                        </div>
                    </div>

                    <!-- Text Output -->
                    <div style="width: 100%; max-width: 780px;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <strong>Response modality:</strong>
                            <span id="modalityLabel">AUDIO</span>
                            <button id="clearTextBtn" class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" style="margin-left:auto;">
                                Clear Text
                            </button>
                        </div>
                        <div id="responseTextBox" style="min-height: 120px; border: 1px solid #ddd; border-radius: 4px; padding: 8px; overflow-y:auto; white-space:pre-wrap;"></div>
                    </div>
                    <div id="chatLog"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- (Removed duplicate pdf.js module script; single loader kept in <head>) -->

    <script defer>
        // -------- Lightweight Client Logger ---------
        const ClientLogger = (() => {
            const levels = { error:0, warn:1, info:2, debug:3 };
            let currentLevel = 'info';
            let verboseAudio = false;
            const lastMessageAt = new Map();
            const THROTTLE_MS = 1500; // collapse identical spammy messages
            function setLevel(l){ currentLevel = l in levels ? l : 'info'; }
            function setVerboseAudio(v){ verboseAudio = !!v; }
            function shouldLog(l){ if(currentLevel==='off') return false; return levels[l] <= levels[currentLevel]; }
            function logAt(l, args){
                if(!shouldLog(l)) return;
                try {
                    const key = JSON.stringify(args);
                    const now = performance.now();
                    const last = lastMessageAt.get(key) || 0;
                    if(now - last < THROTTLE_MS && l !== 'error') return; // throttle non-error repeats
                    lastMessageAt.set(key, now);
                } catch(e){}
                // Delegate to native console
                (console[l]||console.log)(...args);
            }
            return {
                error: (...a)=>logAt('error', a),
                warn: (...a)=>logAt('warn', a),
                info: (...a)=>logAt('info', a),
                debug: (...a)=>logAt('debug', a),
                audio: (...a)=>{ if(verboseAudio) logAt('debug', a); },
                setLevel, setVerboseAudio
            };
        })();
        window.AppLogger = ClientLogger;

        // Hook up UI controls after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            const levelSel = document.getElementById('logLevelSelect');
            const audioChk = document.getElementById('logVerboseAudio');
            if(levelSel){ levelSel.addEventListener('change', ()=> AppLogger.setLevel(levelSel.value)); }
            if(audioChk){ audioChk.addEventListener('change', ()=> AppLogger.setVerboseAudio(audioChk.checked)); }
        });
    // WebSocket dynamic port list (backend now may shift if base port busy)
    const WS_BASE_PORT = 9082;
    const WS_CANDIDATE_PORTS = Array.from({length:10}, (_,i)=> WS_BASE_PORT + i);
    let wsChosenPort = null;
    const assistantSwitch = document.getElementById('assistantSwitch');
    const voiceAssistantToggle = document.getElementById('voice-assistant-toggle');

    // PDF form elements
    const pdfUploadPanel = document.getElementById('pdfUploadPanel');
    const pdfUploadForm = document.getElementById('pdfUploadForm');
    const pdfFileInput = document.getElementById('pdfFileInput');
    const pdfUploadStatus = document.getElementById('pdfUploadStatus');
    const pdfWarnings = document.getElementById('pdfWarnings');
    const pdfFormCard = document.getElementById('pdfFormCard');
    const pdfFieldSummary = document.getElementById('pdfFieldSummary');
    const pdfFormMetaNote = document.getElementById('pdfFormMetaNote');
    const btnResetPdf = document.getElementById('btnResetPdf');
    const btnDownloadPdf = document.getElementById('btnDownloadPdf');
    const pdfCompletionBanner = document.getElementById('pdfCompletionBanner');
    const pdfViewerContainer = document.getElementById('pdfViewerContainer');
    const pdfPagesEl = document.getElementById('pdfPages');

    let webSocket = null;
        let audioContext = null;
        let playbackWorkletNode = null;
        let recordingWorkletNode = null;
        let mediaStream = null;
    // Buffer for early audio chunks that arrive before playback pipeline is ready
    const pendingAudioQueue = [];
    let playbackReady = false;
    const clearTextBtn = document.getElementById('clearTextBtn');
    const modalityLabel = document.getElementById('modalityLabel');
    const responseTextBox = document.getElementById('responseTextBox');

        // PDF session state
    let pdfSchema = null;
    let pdfFormId = null;
    let pdfState = {}; // fieldName -> value
    let pdfConfirmed = {}; // fieldName -> bool
    let pdfAllConfirmed = false;
    let pdfDownloadReady = false;
    let pdfFieldsOrder = [];
    let pdfOriginalToSchema = {}; // original name -> schema unique name
    let pdfSchemaToOriginal = {}; // schema unique -> original
    let pdfJsDoc = null;
    const pdfFieldDomMap = new Map(); // original_name -> element(s)

    // Removed profile state variables

    function resetPdfState() {
        pdfSchema = null;
        pdfFormId = null;
        pdfState = {};
        pdfConfirmed = {};
        pdfFieldsOrder = [];
        pdfDownloadReady = false;
        pdfCompletionBanner.textContent = '';
        pdfFormCard.style.display = 'none';
        pdfUploadPanel.style.display = 'block';
        voiceAssistantToggle.style.display = 'none';
        try { if(webSocket && webSocket.readyState===WebSocket.OPEN){ webSocket.close(); } } catch(e){}
    }

    function sendUserEdit(field, value) {
        if (!webSocket || webSocket.readyState !== WebSocket.OPEN) return;
        webSocket.send(JSON.stringify({ user_edit: { field, value } }));
        AppLogger.debug('Sent user_edit', field, value);
    }

    window.addEventListener("load", async () => {
        // MDL upgrade
        if (window.componentHandler) { componentHandler.upgradeDom(); }
        assistantSwitch.addEventListener('change', (event) => {
            if (event.currentTarget.checked) {
                AppLogger.info("Voice assistant enabled. Connecting WebSocket.");
                startAudioInput();
            } else {
                AppLogger.info("Voice assistant disabled. Disconnecting WebSocket.");
                stopAudioInput();
                if (webSocket) { try { webSocket.close(); } catch(e){} webSocket = null; }
            }
        });
    });

    async function connect() {
        if(webSocket && (webSocket.readyState===WebSocket.OPEN || webSocket.readyState===WebSocket.CONNECTING)) return;
        for(const port of WS_CANDIDATE_PORTS){
            try {
                await new Promise((resolve, reject)=>{
                    const url = `ws://localhost:${port}`;
                    AppLogger.info('WS attempting', url);
                    const ws = new WebSocket(url);
                    let settled = false;
                    const timer = setTimeout(()=>{ if(!settled){ try { ws.close(); } catch(_){} reject(new Error('timeout')); }}, 4000);
                    ws.onopen = () => { settled = true; clearTimeout(timer); webSocket = ws; wsChosenPort = port; resolve(); };
                    ws.onerror = (e) => { if(!settled){ settled=true; clearTimeout(timer); reject(e);} };
                    ws.onclose = (e) => { if(!settled){ settled=true; clearTimeout(timer); reject(e);} AppLogger.info('WS closed', e.code, e.reason); };
                    ws.onmessage = receiveMessage;
                });
                AppLogger.info('WS connected on port', wsChosenPort);
                sendInitialSetupMessage();
                return;
            } catch(e){
                AppLogger.warn('WS port failed', port, e?.message||e);
            }
        }
        AppLogger.error('All WS candidate ports failed. Backend may not be running.');
    }

    function sendInitialSetupMessage() {
        if(!pdfSchema || !pdfFieldsOrder.length){ AppLogger.debug('Setup deferred until PDF loaded'); }
        const model = document.getElementById('modelSelect').value;
        const voiceName = document.getElementById('voiceSelect').value;
        const enableVad = document.getElementById('vadCheckbox').checked;
        const responseModalities = ["AUDIO"]; modalityLabel.textContent = 'AUDIO';
        const setup_client_message = {
            setup: {
                generation_config: { response_modalities: responseModalities, temperature: 0.9 },
                model: model,
                voice_name: voiceName,
                enable_vad: enableVad,
                pdf_field_names: pdfFieldsOrder,
                pdf_form_id: pdfFormId
            }
        };
        try { webSocket.send(JSON.stringify(setup_client_message)); } catch(e){ AppLogger.warn('Failed to send setup', e); }
    }


        function sendVoiceMessage(pcmData) {
            const buffer = pcmData.buffer;
            const base64 = btoa(
                String.fromCharCode.apply(null, new Uint8Array(buffer))
            );

            if (webSocket == null || webSocket.readyState !== WebSocket.OPEN) {
                AppLogger.warn("Cannot send realtime_input - WS not open");
                return;
            }

            const payload = {
                realtime_input: {
                    media_chunks: [{
                            mime_type: "audio/pcm",
                            data: base64,
                        }
                    ],
                },
            };

            webSocket.send(JSON.stringify(payload));
            AppLogger.debug("Realtime input sent", payload?.realtime_input ? Object.keys(payload.realtime_input) : Object.keys(payload));
        }

    function receiveMessage(event) {
            const messageData = JSON.parse(event.data);
            const response = new Response(messageData);

            // PDF completion notification
            if (messageData.form_complete) {
                showPdfConfirmationPrompt();
            }
            if (messageData.download_ready) {
                pdfDownloadReady = true;
                pdfCompletionBanner.textContent = 'Download ready. You may now download the filled PDF.';
                btnDownloadPdf.style.display='inline-block';
            }
            if (messageData.error && messageData.error === 'unknown_form') {
                showInactivityBanner();
            }

            // PDF form tool responses
            if (messageData.form_tool_response) {
                const { updated } = messageData.form_tool_response;
                Object.entries(updated || {}).forEach(([k,v]) => { pdfState[k] = v; pdfConfirmed[k] = true; });
                refreshPdfFieldSummary();
                syncPdfJsDom();
            }
            if (messageData.form_state) {
                refreshPdfFieldSummary();
                syncPdfJsDom();
            }
            if (messageData.download_ready) {
                pdfDownloadReady = true;
                pdfCompletionBanner.textContent = 'Download ready.';
                btnDownloadPdf.style.display='inline-block';
            }

            if (response.text) {
                if (modalityLabel.textContent === 'TEXT') appendToResponseBox(response.text); else displayMessage('GEMINI: ' + response.text);
            }
            if (response.audioData) {
                if (!playbackReady) {
                    // Stash until playback node/AudioContext initialized
                    pendingAudioQueue.push({chunk: response.audioData, mime: messageData.audio_mime_type || 'audio/pcm'});
                    AppLogger.audio('Audio chunk queued. Queue length=', pendingAudioQueue.length);
                } else {
                    injestAudioChuckToPlay(response.audioData, messageData.audio_mime_type || 'audio/pcm');
                }
            }
        }

        function appendToResponseBox(text) {
            if (!text) return;
            responseTextBox.textContent += text;
            responseTextBox.scrollTop = responseTextBox.scrollHeight;
        }

        function base64ToArrayBuffer(base64) {
          const binaryString = window.atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        }

        function convertPCM16LEToFloat32(pcmData) {
           const inputArray = new Int16Array(pcmData);
           const float32Array = new Float32Array(inputArray.length);

           for (let i = 0; i < inputArray.length; i++) {
              float32Array[i] = inputArray[i] / 32768;
           }

          return float32Array;
        }


        async function injestAudioChuckToPlay(base64AudioChunk, mimeType) {
           try {
            AppLogger.audio("Playback chunk received");
              if (!playbackWorkletNode) {
                console.error("Playback worklet node not initialized.");
                return;
              }
              if (audioContext && audioContext.state === "suspended") {
                 await audioContext.resume();
                 AppLogger.audio("Playback context resumed");
              }
              const arrayBuffer = base64ToArrayBuffer(base64AudioChunk);
             let float32Data = convertPCM16LEToFloat32(arrayBuffer);
             // Simple resample safeguard if sampleRate mismatch (assume server 24k -> context 16k) based on length heuristics
             if (audioContext.sampleRate === 16000 && float32Data.length % 3 === 0 && mimeType.includes('pcm')) {
                const factor = 3/2; // 24k -> 16k (approx) if length divisible by 3
                if (float32Data.length / factor > 128) {
                    const targetLen = Math.round(float32Data.length / factor);
                    const down = new Float32Array(targetLen);
                    for (let i=0; i<targetLen; i++) {
                        const srcIndex = i * factor;
                        const i0 = Math.floor(srcIndex);
                        const i1 = Math.min(i0+1, float32Data.length-1);
                        const t = srcIndex - i0;
                        down[i] = float32Data[i0]*(1-t) + float32Data[i1]*t;
                    }
                    float32Data = down;
                }
             }
             playbackWorkletNode.port.postMessage(float32Data);
             AppLogger.audio("Playback frame sent");
            } catch (error) {
               AppLogger.error("Error processing audio chunk", error);
            }
        }


        async function ensureConnected() {
            if (webSocket && webSocket.readyState === WebSocket.OPEN) return;

            const waitForOpen = new Promise((resolve, reject) => {
                let opened = false;
                const timeout = setTimeout(() => {
                    if (!opened) reject(new Error('WebSocket open timeout'));
                }, 4000);
                const onOpen = () => {
                    opened = true;
                    clearTimeout(timeout);
                    if (webSocket) webSocket.removeEventListener('open', onOpen);
                    resolve();
                };
                if (!webSocket || webSocket.readyState !== WebSocket.CONNECTING) {
                    connect();
                }
                if (webSocket) webSocket.addEventListener('open', onOpen);
            });
            try { await waitForOpen; } catch (e) { AppLogger.warn('Could not ensure WS open before recording', e); }
        }

        async function startAudioInput() {
            try {
                AppLogger.debug("Audio init (full) pre-WS");

                // 1. Create and resume a single AudioContext
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    AppLogger.audio("AudioContext created");
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    AppLogger.audio("AudioContext resumed");
                }

                // 2. Get microphone permission and the audio stream
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: { channelCount: 1, sampleRate: 16000 }
                });
                AppLogger.audio("Got microphone media");

                // 3. Load all necessary audio worklet modules
                await Promise.all([
                    audioContext.audioWorklet.addModule('/recording-processor.js'),
                    audioContext.audioWorklet.addModule('/pcm-processor.js')
                ]);
                AppLogger.audio("Worklet modules loaded");

                // 4. Setup recording pipeline
                const source = audioContext.createMediaStreamSource(mediaStream);
                recordingWorkletNode = new AudioWorkletNode(audioContext, 'recording-processor', {
                    processorOptions: { sampleRate: 16000 }
                });
                recordingWorkletNode.port.onmessage = (event) => { sendVoiceMessage(event.data); };
                source.connect(recordingWorkletNode);
                AppLogger.audio("Recording pipeline connected");

                // 5. Setup playback pipeline
                playbackWorkletNode = new AudioWorkletNode(audioContext, "pcm-processor");
                playbackWorkletNode.connect(audioContext.destination);
                AppLogger.audio("Playback pipeline connected");
                playbackReady = true;
                // Flush any queued audio that arrived early
                if (pendingAudioQueue.length) {
                    AppLogger.audio('Flushing queued audio chunks', pendingAudioQueue.length);
                    while (pendingAudioQueue.length) {
                        const item = pendingAudioQueue.shift();
                        await injestAudioChuckToPlay(item.chunk, item.mime);
                    }
                }

                // 6. NOW, connect the WebSocket after all audio setup is complete.
                AppLogger.info("Audio setup complete; connecting WS next");
                await ensureConnected();
                
                if (modalityLabel.textContent === 'TEXT') {
                    responseTextBox.textContent = '';
                }

            } catch (error) {
                AppLogger.error("Error starting audio input", error);
                alert("Could not start audio recording: " + error.message);
            }
        }

        function stopAudioInput() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (recordingWorkletNode) {
                recordingWorkletNode.disconnect();
                recordingWorkletNode = null;
            }
            if (playbackWorkletNode) {
                playbackWorkletNode.disconnect();
                playbackWorkletNode = null;
            }
            if (audioContext) {
                audioContext.close().then(() => {
                    audioContext = null;
                });
            }

            // Signal end of audio stream turn (allows model to respond sooner)
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                try { webSocket.send(JSON.stringify({ realtime_input: { audio_stream_end: true } })); AppLogger.debug('Sent audio_stream_end'); } catch(e){ AppLogger.warn('Failed to send audio_stream_end', e); }
            }
        }

        function displayMessage(message) {
           AppLogger.debug('WS message', message?.slice ? message.slice(0,140) : message);
            addParagraphToDiv("chatLog", message);
        }

        function addParagraphToDiv(divId, text) {
           const newParagraph = document.createElement("p");
           newParagraph.textContent = text;
           const div = document.getElementById(divId);
           div.appendChild(newParagraph);
        }

        // ------- PDF Upload Flow -------
        pdfUploadForm.addEventListener('submit', async (e)=>{
            e.preventDefault();
            const file = pdfFileInput.files && pdfFileInput.files[0];
            pdfWarnings.textContent=''; pdfUploadStatus.textContent='';
            if(!file){ pdfUploadStatus.textContent='Select a PDF file.'; return; }
            if(file.size > 5*1024*1024){ pdfUploadStatus.textContent='File too large (>5MB).'; return; }
            pdfUploadStatus.textContent='Uploading...';
            try {
                const formData = new FormData();
                formData.append('file', file);
                const resp = await fetch('/upload_form', { method:'POST', body: formData });
                const data = await resp.json();
                if(!data.ok){ pdfUploadStatus.textContent='Error: '+ (data.message||data.error||'upload failed'); return; }
                let statusLine = 'Parsed '+data.schema.field_count+' field(s).';
                if(data.replaced_previous){ statusLine += ' (Previous form replaced.)'; }
                pdfUploadStatus.textContent = statusLine;
                if(data.warnings){ pdfWarnings.textContent = 'Warnings: '+ data.warnings.join(', '); }
                pdfSchema = data.schema; pdfFormId = data.schema.form_id;
                pdfSchemaToOriginal = (pdfSchema.metadata && pdfSchema.metadata.write_name_map) || {};
                pdfOriginalToSchema = (pdfSchema.metadata && pdfSchema.metadata.original_to_schema) || {};
                console.log('[FRONTEND] Upload response form_id:', data.schema.form_id);
                console.log('[FRONTEND] Set pdfFormId to:', pdfFormId);
                // Use geometric ordering from backend (already sorted) but keep explicit copy
                pdfFieldsOrder = data.schema.fields.map(f=>f.name);
                pdfState = {}; pdfConfirmed = {}; pdfFieldsOrder.forEach(n=>{ pdfState[n]=null; pdfConfirmed[n]=false; });
                // Extra metadata warnings
                const meta = pdfSchema.metadata || {};
                const extraNotes = [];
                if(meta.truncated_to_first_page){ extraNotes.push('Only first page processed.'); }
                if(meta.field_cap_reached){ extraNotes.push('Field cap reached; some fields ignored.'); }
                if(extraNotes.length){ pdfWarnings.textContent += (pdfWarnings.textContent? ' ':'') + extraNotes.join(' '); }
                
                pdfFormCard.style.display='block';
                voiceAssistantToggle.style.display = 'block';
                // Hide legacy stacked UI elements (deprecated) and render inline PDF
                // Legacy stacked field container removed; inline pdf.js form used instead.
                refreshPdfFieldSummary();
                await renderPdfInline();
                AppLogger.debug('renderPdfInline invoked after upload');
                syncPdfJsDom();
                
            } catch(err){
                AppLogger.error('Upload failed', err); pdfUploadStatus.textContent='Upload failed.';
            }
        });

        btnResetPdf.addEventListener('click', async ()=>{
            if(!pdfFormId){ return; }
            await fetch('/reset_form', { method:'POST' });
            resetPdfState();
        });

        btnDownloadPdf.addEventListener('click', async ()=>{
            if(!pdfDownloadReady && pdfFormId){ /* Still allow attempt once complete locally */ }
            if(!pdfFormId){ return; }
            console.log('[FRONTEND] Starting download for form_id:', pdfFormId);
            const resp = await fetch('/download_filled/'+pdfFormId);
            console.log('[FRONTEND] Download response status:', resp.status, resp.statusText);
            if(!resp.ok){
                let detail = '';
                try { const j = await resp.json(); detail = j.message || j.error || ''; } catch(e) {}
                alert('Download failed '+ (detail? ('- '+detail) : '(not ready?)'));
                return;
            }
            const blob = await resp.blob();
            console.log('[FRONTEND] Created blob, size:', blob.size, 'type:', blob.type);
            
            // Try URL.createObjectURL first
            const urlAPI = window.URL || window.webkitURL;
            if (urlAPI && urlAPI.createObjectURL) {
                console.log('[FRONTEND] Using URL.createObjectURL method');
                // (Removed duplicated inline PDF helpers – using unified versions below)
                const url = urlAPI.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; 
                a.download = 'filled_'+ (pdfSchema?.metadata?.original_filename || 'form.pdf') ;
                document.body.appendChild(a); a.click(); a.remove();
                setTimeout(()=> urlAPI.revokeObjectURL(url), 3000);
            } else {
                // Fallback data URL method
                const reader = new FileReader();
                reader.onload = function(e) {
                    const a = document.createElement('a');
                    a.href = e.target.result;
                    a.download = 'filled_'+ (pdfSchema?.metadata?.original_filename || 'form.pdf');
                    document.body.appendChild(a); a.click(); a.remove();
                };
                reader.readAsDataURL(blob);
            }
        });

        // ---- Inline PDF utility functions (moved out of download handler) ----
        function refreshPdfFieldSummary(){
            if(!pdfSchema){ pdfFieldSummary.textContent=''; return; }
            let total = pdfFieldsOrder.length;
            // Consider a field filled if it has a non-empty string, a finite number, true boolean, or non-null object/array
            let filled = Object.values(pdfState).filter(v=>{
                if(v === null || v === undefined) return false;
                if(typeof v === 'string') return v.trim().length>0;
                if(typeof v === 'boolean') return v === true; // only true counts for checkboxes
                if(typeof v === 'number') return true;
                return true; // objects (e.g., future structured) count
            }).length;
            pdfFieldSummary.textContent = `${filled} of ${total} fields filled.`;
        }

        async function renderPdfInline(){
            if(!pdfFormId){ AppLogger.warn('renderPdfInline: missing formId'); return; }
            const url = `/original_pdf/${pdfFormId}`;
            AppLogger.info('Rendering PDF inline', url);
            try {
                const probe = await fetch(url, { method:'GET' });
                if(!probe.ok){ AppLogger.error('original_pdf fetch failed status', probe.status); return; }
                const loadingTask = window.pdfjsLib.getDocument({ url });
                pdfJsDoc = await loadingTask.promise;
                pdfPagesEl.innerHTML='';

                // Iterate pages; render canvas + annotation layer with interactive forms
                for(let pageNum = 1; pageNum <= pdfJsDoc.numPages; pageNum++){
                    const pdfPage = await pdfJsDoc.getPage(pageNum);
                    const viewport = pdfPage.getViewport({ scale: 1.15 });
                    const pageWrapper = document.createElement('div');
                    pageWrapper.className='pdf-page';
                    pageWrapper.style.position='relative';
                    pageWrapper.style.width = viewport.width + 'px';
                    pageWrapper.style.height = viewport.height + 'px';
                    pageWrapper.style.margin='0 auto 24px auto';

                    // Canvas layer
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = viewport.width; canvas.height = viewport.height;
                    canvas.style.display='block';
                    pageWrapper.appendChild(canvas);
                    pdfPagesEl.appendChild(pageWrapper);
                    await pdfPage.render({ canvasContext: ctx, viewport }).promise;

                    // Annotation layer container
                    const annLayerDiv = document.createElement('div');
                    annLayerDiv.className='annotationLayer';
                    annLayerDiv.style.width = canvas.style.width || (viewport.width + 'px');
                    annLayerDiv.style.height = canvas.style.height || (viewport.height + 'px');
                    pageWrapper.appendChild(annLayerDiv);

                    // Render interactive forms using available API
                    try {
                        const annotations = await pdfPage.getAnnotations({ intent:'display' });
                        const pdfjsLib = window.pdfjsLib;
                        const params = {
                            annotations,
                            div: annLayerDiv,
                            page: pdfPage,
                            viewport,
                            renderInteractiveForms: true,
                            linkService: { getDestinationHash:()=>'', navigateTo:()=>{} },
                            annotationStorage: (pdfjsLib.AnnotationStorage ? new pdfjsLib.AnnotationStorage() : undefined),
                            enableScripting: false
                        };
                        if(pdfjsLib.AnnotationLayer && pdfjsLib.AnnotationLayer.render){
                            pdfjsLib.AnnotationLayer.render(params);
                        } else if(pdfjsLib.renderAnnotationLayer){
                            pdfjsLib.renderAnnotationLayer(params);
                        } else {
                            // Fallback: naive widget creation
                            annotations.forEach(ann=>{
                                if(!ann || !ann.fieldName || !ann.rect || (ann.subtype||'').toLowerCase()!=='widget') return;
                                let el;
                                if(ann.checkBox){ el=document.createElement('input'); el.type='checkbox'; }
                                else if(ann.radioButton){ el=document.createElement('input'); el.type='radio'; el.value=ann.exportValue||'On'; el.name=ann.fieldName; }
                                else { el=document.createElement('input'); el.type='text'; el.value=ann.fieldValue||''; }
                                el.name = ann.fieldName;
                                let r = ann.rect; try { if(pdfjsLib.Util && pdfjsLib.Util.normalizeRect) r = pdfjsLib.Util.normalizeRect(r); } catch(_){ }
                                let vrect = r; try { vrect = viewport.convertToViewportRectangle(r); } catch(_){ }
                                const [x1,y1,x2,y2] = vrect;
                                const w = Math.abs(x2-x1); const h=Math.abs(y2-y1);
                                el.style.position='absolute';
                                el.style.left = Math.min(x1,x2)+'px';
                                el.style.top = Math.min(y1,y2)+'px';
                                el.style.width = (w>4?w:40)+'px';
                                el.style.height = (h>8?h:16)+'px';
                                el.style.fontSize='11px';
                                annLayerDiv.appendChild(el);
                            });
                        }
                    } catch(e){ AppLogger.warn('Annotation layer failed page '+pageNum, e); }
                }

                collectPdfJsFormFields(pdfPagesEl);
                AppLogger.info('PDF rendered; collected form elements', pdfFieldDomMap.size);
                pdfFormCard.style.display='block';
                voiceAssistantToggle.style.display='block';
                connect();
            } catch(err){
                AppLogger.error('renderPdfInline failed', err);
            }
        }

        function collectPdfJsFormFields(container){
            pdfFieldDomMap.clear();
            const elements = container.querySelectorAll('input,select,textarea');
            elements.forEach(el => {
                const name = el.name || el.getAttribute('name') || el.getAttribute('data-name');
                if(!name) return;
                if(!pdfFieldDomMap.has(name)) pdfFieldDomMap.set(name, []);
                pdfFieldDomMap.get(name).push(el);
                el.addEventListener('change', () => {
                    const schemaName = pdfOriginalToSchema[name] || name;
                    let value;
                    if(el.type === 'checkbox') value = el.checked; else if(el.type === 'radio'){ if(el.checked) value=el.value; else return; } else value = el.value;
                    pdfState[schemaName] = value; refreshPdfFieldSummary();
                    if(webSocket && webSocket.readyState===WebSocket.OPEN){ sendUserEdit(schemaName, value); }
                });
            });
        }

        function syncPdfJsDom(){
            pdfFieldDomMap.forEach((els, originalName) => {
                const schemaName = pdfOriginalToSchema[originalName] || originalName;
                const val = pdfState[schemaName];
                els.forEach(el => {
                    if(el.type === 'checkbox') el.checked = !!val; else if(el.type === 'radio') el.checked = (el.value===val); else if(val!==undefined && val!==null) el.value = val;
                });
            });
        }

        function showPdfConfirmationPrompt(){
            if(document.getElementById('pdfConfirmPrompt')) return;
            const div = document.createElement('div');
            div.id = 'pdfConfirmPrompt';
            div.style.marginTop='14px';
            div.style.padding='10px 12px';
            div.style.background='#fff5f1';
            div.style.border='1px solid #f5a076';
            div.style.borderRadius='8px';
            div.style.fontSize='13px';
            div.innerHTML = `<strong>All fields captured.</strong> Please confirm all values are correct.
                <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
                    <button class="pill-btn" id="btnConfirmPdf">Confirm & Generate</button>
                    <button class="pill-btn alt" id="btnReviewPdf">Review Fields</button>
                </div>`;
            pdfFormCard.appendChild(div);
            div.querySelector('#btnConfirmPdf').addEventListener('click', ()=>{
                // Send confirm_form message
                if(webSocket && webSocket.readyState===WebSocket.OPEN){
                    webSocket.send(JSON.stringify({ confirm_form: true }));
                }
                pdfCompletionBanner.textContent='Confirmation sent. Preparing file...';
            });
            div.querySelector('#btnReviewPdf').addEventListener('click', ()=>{ div.remove(); });
        }
        function removePdfConfirmationPrompt(){
            const d = document.getElementById('pdfConfirmPrompt'); if(d) d.remove();
        }

        // ------- Inactivity Handling -------
        let pdfStatusPollTimer = null;
        function startPdfStatusPolling(){
            stopPdfStatusPolling();
            if(!pdfFormId) return;
            pdfStatusPollTimer = setInterval(async ()=>{
                try {
                    const resp = await fetch('/form_status/'+pdfFormId);
                    if(resp.status === 404){ showInactivityBanner(); stopPdfStatusPolling(); return; }
                    if(!resp.ok) return;
                    const data = await resp.json();
                    if(!data.ok){ if(data.error==='unknown_form'){ showInactivityBanner(); stopPdfStatusPolling(); } return; }
                } catch(e){ /* network error ignored */ }
            }, 30000); // every 30s
        }
        function stopPdfStatusPolling(){ if(pdfStatusPollTimer){ clearInterval(pdfStatusPollTimer); pdfStatusPollTimer=null; } }
        function showInactivityBanner(){
            if(!pdfFormCard) return;
            let b = document.getElementById('pdfInactiveBanner');
            if(!b){
                b = document.createElement('div');
                b.id='pdfInactiveBanner';
                b.style.marginTop='12px';
                b.style.padding='10px 12px';
                b.style.background='#ffe8e6';
                b.style.border='1px solid #ff9b92';
                b.style.borderRadius='8px';
                b.style.fontSize='12px';
                b.style.color='#7a1e1a';
                b.textContent = 'Session expired due to inactivity. Please reset or upload a new PDF.';
                pdfFormCard.appendChild(b);
            }
        }

        function escapeHtml(str){
            return str.replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }


    class Response {
            constructor(data) {
               this.text = null;
               this.audioData = null;
                this.endOfTurn = null;

               if(data.text){
                  this.text = data.text
               }

                if (data.audio) {
                   this.audioData = data.audio;
                }
            }
         }

    // Removed automatic suggestion scheduling; assistant must wait for explicit user answers.
    </script>
</body>

</html>